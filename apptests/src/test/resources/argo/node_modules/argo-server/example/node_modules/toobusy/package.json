{
  "name": "toobusy",
  "description": "Don't fall over when your Node.JS server is too busy.",
  "homepage": "https://github.com/lloyd/node-toobusy",
  "version": "0.2.2",
  "dependencies": {
    "bindings": "1.0.0"
  },
  "devDependencies": {
    "should": "1.2.1",
    "mocha": "1.7.0"
  },
  "maintainers": [
    {
      "name": "Lloyd Hilaiel",
      "email": "lloyd@hilaiel.com"
    }
  ],
  "bugs": {
    "url": "https://github.com/lloyd/node-toobusy/issues"
  },
  "licenses": [
    {
      "type": "WTFPL"
    }
  ],
  "repositories": [
    {
      "type": "git",
      "url": "git://github.com/lloyd/node-toobusy.git"
    }
  ],
  "main": "./index.js",
  "engines": {
    "node": ">=0.8.0"
  },
  "scripts": {
    "test": "mocha tests",
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "# Is Your Node Process Too Busy?\n\n[![Build Status](https://secure.travis-ci.org/lloyd/node-toobusy.png)](http://travis-ci.org/lloyd/node-toobusy)\n\nWhat happens when your service is overwhelmed with traffic?\nYour server can do one of two things:\n\n  * Stop working, or...\n  * Keep serving as many requests as possible\n\nThis library helps you do the latter.\n\n## How it works\n\n`toobusy` polls the node.js event loop and keeps track of \"lag\",\nwhich is long requests wait in node's event queue to be processed.\nWhen lag crosses a threshold, `toobusy` tells you that you're *too busy*.\nAt this point you can stop request processing early\n(before you spend too much time on them and compound the problem),\nand return a \"Server Too Busy\" response.\nThis allows your server to stay *responsive* under extreme load,\nand continue serving as many requests as possible.\n\n## installation\n\n```\nnpm install toobusy\n```\n\n\n## usage\n\n```javascript\nvar toobusy = require('toobusy'),\n    express = require('express');\n    \nvar app = express();\n    \n// middleware which blocks requests when we're too busy\napp.use(function(req, res, next) {\n  if (toobusy()) {\n    res.send(503, \"I'm busy right now, sorry.\");\n  } else {\n    next();\n  } \n});\n    \napp.get('/', function(req, res) {\n  // processing the request requires some work!\n  var i = 0;\n  while (i < 1e5) i++;\n  res.send(\"I counted to \" + i);\n});\n  \nvar server = app.listen(3000);\n  \nprocess.on('SIGINT', function() {\n  server.close();\n  // calling .shutdown allows your process to exit normally\n  toobusy.shutdown();\n  process.exit();\n});\n```\n\n## tunable parameters\n\nThe one knob that the library exposes is \"maximum lag\".\nThis number represents the maximum amount of time in milliseconds that the event queue is behind,\nbefore we consider the process *too busy*.\n\n```javascript\n// set maximum lag to an aggressive value\nrequire('toobusy').maxLag(10);\n```\n\nThe default value is 70ms,\nwhich allows an \"average\" server to run at 90-100% CPU\nand keeps request latency at around 200ms.\nFor comparison, a value of 10ms results in 60-70% CPU usage,\nwhile latency for \"average\" requests stays at about 40ms.\n\nThese numbers are only examples,\nand the specifics of your hardware and application can change them drastically,\nso experiment!\nThe default of 70 should get you started.\n\n## license\n\n[WTFPL](http://wtfpl.org)\n",
  "readmeFilename": "README.md",
  "_id": "toobusy@0.2.2",
  "dist": {
    "shasum": "9f486d43a3f630808e719803772cb7401fba6520"
  },
  "_from": "toobusy"
}
